import proposalModel = require('../../models/proposalModel');
import {IMainCategory, ISubCategory} from '../../models/categoryModel';

import Q = require('q');
import { Promise } from "q";

interface IBigNumber {
    toNumber(): number
}

/**
 * Service for dealing with buying proposals on the blockchain. All functions
 * return promises.
 */
export class CategoryService {
    constructor() {
    }

    /**
     * Get the main categories with the total proposal count.
     */
    getMainCategories(): PromiseLike<IMainCategory[]> {
        // The type of the result is incorrectly inferred as IProposalDocument[], while it is actually
        // an array of custom JS objects generated by the aggregate(). We cast it to IMainCategory[]
        // as we have included all its required properties and we want to keep this method type safe 
        // to call.
        return <PromiseLike<IMainCategory[]>><any>proposalModel.Proposal.aggregate(
            // Filters could be added using $match.
            //{ $match: {} },
            {
                $group: {
                    // A group specification MUST contain an _id. So just include the category name twice.
                    _id: '$mainCategory',
                    // To include the actual value we use $last for the value of that field in the "last" record.
                    name: { $last: '$mainCategory' },
                    totalProposalCount: { $sum: 1 }
                }
            })
            .exec();

        // TODO: load image URLs and include them in the data.
    }

    /**
     * Get the sub categories of a main category with the total proposal count.
     */
    getSubCategories(mainCategory: string): PromiseLike<ISubCategory[]> {
        // The type of the result is incorrectly inferred as IProposalDocument[], while it is actually
        // an array of custom JS objects generated by the aggregate(). We cast it to IMainCategory[]
        // as we have included all its required properties and we want to keep this method type safe 
        // to call.
        return <PromiseLike<ISubCategory[]>><any>proposalModel.Proposal.aggregate(           
            {
                $match: {
                    mainCategory: mainCategory
                }
            },
            {
                $group: {
                    // A group specification MUST contain an _id. So just include the category name twice.
                    _id: '$subCategory',
                    // To include the actual value we use $last for the value of that field in the "last" record.
                    name: { $last: '$subCategory' },
                    totalProposalCount: { $sum: 1 }
                }
            })
            .exec();
    }

}